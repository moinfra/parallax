# 通信协议详解

本文档详细描述了上位机终端 (`term.py`) 与龙芯监控程序 (`kernel`) 之间的通信协议。理解此协议是复现、修改或扩展监控程序功能的关键。

## 1. 基本概念

### 通信方式：串行接口 (Serial Port / UART)

**所有通信都通过物理串行接口进行，不存在任何网络协议（如TCP/IP）。**

- **物理连接**: 你需要使用一根串口线（或USB转串口线）将运行 `term.py` 的主机（Host PC）与运行监控程序的龙芯目标平台（FPGA开发板或模拟器）连接起来。
- **设备文件**: 在Linux上，这个串口设备通常表现为 `/dev/ttyS0`、`/dev/ttyUSB0` 或 `/dev/ttyACM0` 等文件。在Windows上，则为 `COM1`、`COM2` 等。
- **`term.py` 的角色**: `term.py` 的核心功能就是打开这个设备文件，然后通过它读写二进制数据，从而与监控程序进行交互。

### 数据格式与模式

- **数据格式**: 所有多字节数据（如32位地址或数值）均采用**小端序 (Little-Endian)** 传输，即低位字节在前，高位字节在后。
- **通信模式**: 采用“请求-响应”模式。上位机发送一个命令，监控程序执行后返回相应的数据或确认信号。

## 2. 协议结构

一次完整的通信交互由以下部分组成：

`上位机 -> 监控程序`: **命令码 (1字节)** + **可选参数 (N字节)**
`监控程序 -> 上位机`: **响应数据 (M字节)**

### 命令码

命令码是一个单字节的ASCII字符，用于告知监控程序执行何种操作。定义在 `kernel/include/shell.h` 中。

| 命令 | ASCII | 十六进制 | 功能描述 |
| :--- | :---- | :--- | :--- |
| `R` | 'R' | `0x52` | **读寄存器 (Read Registers)** |
| `D` | 'D' | `0x44` | **读内存 (Dump Memory)** |
| `A` | 'A' | `0x41` | **写内存 (Write Memory)** |
| `G` | 'G' | `0x47` | **执行 (Go)** |

--- 

## 3. 命令详解

### 3.1 `R` - 读寄存器

- **目的**: 获取用户空间所有通用寄存器的当前值。
- **上位机发送**: `b'R'` (1字节)
- **监控程序响应**: 连续返回 **120字节** 的数据。这对应于从 `$r2` 到 `$r31` 的30个寄存器，每个寄存器4字节。

**复现步骤**:
1.  向上位机发送 `0x52`。
2.  循环接收数据，直到收满120字节。
3.  将这120字节的数据，每4字节为一组，按小端序解析为30个32位整数，分别对应 `$r2` 到 `$r31` 的值。

### 3.2 `D` - 读内存

- **目的**: 读取目标内存中一块连续区域的数据。
- **上位机发送**:
    1.  `b'D'` (1字节命令码)
    2.  `addr` (4字节, 小端序): 要读取的起始地址。
    3.  `num` (4字节, 小端序): 要读取的字节数（必须是4的倍数）。
- **监控程序响应**: 连续返回 `num` 字节的内存数据。

**复现步骤**:
1.  发送 `0x44`。
2.  将起始地址 `addr` 打包成4字节小端序数据并发送。
3.  将要读取的字节数 `num` 打包成4字节小端序数据并发送。
4.  循环接收数据，直到收满 `num` 字节。

### 3.3 `A` - 写内存

- **目的**: 向目标内存中一块连续区域写入数据。
- **上位机发送**:
    1.  `b'A'` (1字节命令码)
    2.  `addr` (4字节, 小端序): 要写入的起始地址。
    3.  `num` (4字节, 小端序): 要写入的字节数（必须是4的倍数）。
    4.  `data` (`num` 字节): 要写入的具体数据。
- **监控程序响应**: 无响应。写入操作完成后，监控程序直接等待下一个命令。

**复现步骤**:
1.  发送 `0x41`。
2.  将起始地址 `addr` 打包成4字节小端序数据并发送。
3.  将要写入的字节数 `num` 打包成4字节小端序数据并发送。
4.  发送 `num` 字节的 `data`。

### 3.4 `G` - 执行

- **目的**: 让CPU跳转到指定地址开始执行用户代码。
- **上位机发送**:
    1.  `b'G'` (1字节命令码)
    2.  `addr` (4字节, 小端序): 用户代码的入口地址。
- **监控程序响应**: 这是一个有时序要求的复杂过程。
    1.  **启动信号**: 监控程序首先会返回 `0x06` (ASCII ACK)，表示“我已收到命令，即将开始执行用户代码”。
    2.  **用户程序输出**: 在执行期间，如果用户程序通过 `WRITESERIAL` 产生任何串口输出，上位机将直接收到这些数据。
    3.  **结束信号**: 当用户程序执行完毕并安全返回后，监控程序会发送 `0x07` (ASCII BEL)，表示“用户程序已结束，我已收回控制权”。

**复现步骤**:
1.  发送 `0x47`。
2.  将入口地址 `addr` 打包成4字节小端序数据并发送。
3.  **等待启动信号**: 阻塞式读取1字节，并校验其是否为 `0x06`。
4.  **进入接收循环**: 持续非阻塞地读取串口：
    -   如果读到 `0x07`，说明执行结束，跳出循环。
    -   如果读到任何其他数据，将其视为用户程序的正常输出，并显示出来。
    -   如果长时间未读到 `0x07`，可能表示用户程序已跑飞或陷入死循环。

## 4. 特殊信号

除了命令交互，协议还定义了两个用于计时的特殊ASCII控制字符。

- `TIMERSET (0x06)`: 在 `G` 命令中，由监控程序发出，标志着用户代码即将开始执行。`term.py` 用它来启动计时器。
- `TIMETOKEN (0x07)`: 在 `G` 命令中，由监控程序发出，标志着用户代码已执行完毕。`term.py` 用它来停止计时器，并计算执行耗时。

## 5. `term.py` 的辅助功能

`term.py` 不仅仅是一个简单的串口终端，它还内置了**龙芯交叉编译工具链**的调用能力。当用户在 `term.py` 中输入 `A` 命令并直接键入汇编代码时，`term.py` 会：

1.  将接收到的汇编代码写入一个临时 `.S` 文件。
2.  在本地调用 `loongarch32r-linux-gnusf-as` 和 `objcopy` 将其汇编成二进制机器码。
3.  最后，通过 `A` 命令的通信协议，将这段即时编译的二进制码写入目标内存。

这个功能极大地简化了开发流程，使得开发者无需离开终端就能完成“编码-编译-加载-运行”的完整闭环。
