# 监控程序工作原理

本文档旨在深入解释 `supervisor-32-la` 监控程序的内部工作机制，帮助开发者理解其从启动、初始化到与用户交互的完整流程。

## 核心思想

该监控程序本质上是一个运行在裸机上的、无限循环的**状态机**。它的核心任务是：

1.  **初始化硬件**：设置最基本的运行环境，如堆栈指针、BSS段等。
2.  **等待外部命令**：通过串口接收来自上位机（`term.py`）的指令。
3.  **解析并执行命令**：根据接收到的指令，执行相应的底层操作（如读写内存、跳转执行）。
4.  **管理上下文**：在执行用户代码和返回监控程序之间，正确地保存和恢复寄存器状态，确保执行流程的可控性。

整个程序是**单线程、阻塞式**的。它在完成一个任务之前不会处理下一个任务。

## 1. 启动流程 (`kernel/kern/init.S`)

程序的入口点是 `START` 标签。启动过程严格按照顺序执行以下任务：

1.  **清空 BSS 段**：
    -   `.bss` 段用于存放未初始化的全局变量和静态变量。程序启动时，这块内存区域的内容是随机的。
    -   代码通过 `_sbss` 和 `_ebss` 这两个由链接脚本定义的地址，定位 BSS 段的开始和结束。
    -   然后，它通过一个循环，将这块内存区域逐字（word by word）清零。

2.  **设置堆栈**：
    -   **内核堆栈**：初始化内核的堆栈指针 `sp` 和帧指针 `fp`。这是监控程序自身运行时所使用的堆栈。
    -   **用户堆栈**：为即将运行的用户程序准备一个独立的堆栈空间，并将其地址保存在一个全局变量中。

3.  **初始化线程控制块 (TCB)**:
    -   尽管这是一个简单的监控程序，但它引入了“线程”的抽象概念，定义了两个线程：`thread0` (idle) 和 `thread1` (shell/user)。
    -   它为这两个线程分别分配了中断帧（Trap Frame）的内存空间，并保存在 `TCBT` (Thread Control Block Table) 中。
    -   在当前的设计中，它直接将 `current` 线程设置为 `thread1`，准备进入交互式 Shell。

4.  **打印欢迎信息**：
    -   通过 `WRITESERIAL` 函数，逐字节向串口打印一条启动成功的信息。

5.  **跳转到 Shell**：
    -   所有初始化完成后，程序通过 `jirl` 指令跳转到 `SHELL` 标签，进入主交互循环，将控制权交给用户。

## 2. 核心交互循环 (`kernel/kern/shell.S`)

`SHELL` 是程序的主循环，它永远不会主动退出。其工作流程如下：

1.  **读取命令**：调用 `READSERIAL` 函数，从串口读取一个字节。这是一个阻塞操作，程序会一直等待直到接收到数据。

2.  **命令分发**：
    -   程序将接收到的字节（ASCII码）与预设的命令字符（'r', 'd', 'a', 'g'）进行比较。
    -   使用 `beq` (Branch if Equal) 指令，如果匹配成功，则跳转到对应的命令处理代码块（如 `.OP_R`, `.OP_D` 等）。
    -   如果没有任何匹配，则直接跳转到 `.DONE`，然后再次回到 `SHELL` 的开头，等待下一个命令。

## 3. `go` 命令与上下文切换

`go` 命令是整个监控程序最核心、最复杂的功能。它实现了从**监控程序（内核态）**到**用户程序（用户态）**的“上下文切换”。

这里的“上下文”主要指 **CPU 通用寄存器的状态**。

#### 上下文保存区 `uregs`

在 `shell.S` 中，定义了一个名为 `uregs` 的内存区域。它像一个“暂存盘”，专门用于在执行用户代码前后，保存和恢复32个通用寄存器的值。

#### “go” 的执行流程

1.  **获取入口地址**：首先，通过 `READSERIALWORD` 从串口读取一个32位的地址，这是用户程序的入口点。

2.  **准备切换**：
    -   通知终端，用户程序即将开始运行。
    -   将当前的内核堆栈指针 `sp` 保存到 `uregs` 的特定位置。

3.  **恢复用户上下文**：
    -   从 `uregs` 中，将之前保存的用户寄存器值，依次加载回 CPU 的 `$r2` - `$r31` 寄存器。
    -   *注意*：首次运行时，`uregs` 是空的（或由用户通过 `a` 命令预设），这相当于为用户程序设置了初始寄存器状态。

4.  **跳转执行**：
    -   使用 `jirl` (Jump and Link Register) 指令，无条件跳转到第一步获取的用户程序入口地址。
    -   CPU 开始执行用户代码。

#### 从用户程序返回

监控程序的设计依赖于一个重要的**约定**：用户程序执行完毕后，必须主动跳转回监控程序预留的返回点 (`.USERRET2`)。

1.  **保存用户上下文**：
    -   程序返回到 `.USERRET2` 后，第一件事就是将此刻 CPU 中所有通用寄存器的值，全部写回到 `uregs` 内存区域中。这保存了用户程序执行结束时的“快照”。

2.  **恢复监控程序上下文**：
    -   从 `uregs` 中恢复监控程序的堆栈指针 `sp`。

3.  **通知并返回 Shell**：
    -   向终端发送一个信号，表示用户程序已执行完毕。
    -   跳转回 `SHELL` 的开头，等待下一个用户命令。

这种切换方式是**协作式**的，而非抢占式的。如果用户程序跑飞或陷入死循环，它将永远不会返回，监控程序也会失去控制权。

## 4. 硬件抽象

监控程序通过调用 `READSERIAL` 和 `WRITESERIAL` 等函数与硬件通信，但它本身并没有实现这些函数。它仅仅是跳转到这些函数固定的内存地址。

这是一种简单的硬件抽象层（HAL）思想。只要目标平台（FPGA或QEMU）在指定地址提供了这些功能的实现，监控程序就可以在不修改代码的情况下运行，具有一定的可移植性。
