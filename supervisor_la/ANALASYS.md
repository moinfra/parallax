好的，这是一份详细的文档，汇总了汇编代码中各个例程与最终反汇编代码中对应绝对地址的关系。

---

## LoongArch32 内核汇编代码例程地址分析文档

### 1. 文档目的

本文档旨在分析LoongArch32架构下内核汇编代码（来自`evec.S`, `init.S`, `shell.S`, `test.S`, `utils.S`）中定义的各个函数和全局变量，并确定它们在最终链接后的程序映像中的绝对内存地址。分析基于提供的反汇编输出、源代码片段和链接脚本（`kernel.ld`）。

### 2. 地址空间和段映射

根据`kernel.ld`链接脚本，程序内存布局如下：

*   `.data` 段：起始于 `0x00000000` (反汇编输出中的基址)。此段主要包含只读数据或初始化数据。
*   `.bss` 段：起始于 `0x807F0000`。此段包含未初始化的全局变量，在程序启动时会被清零。
    *   `.bss.uregs` 子段：位于 `.bss` 段的开始，用于存放用户寄存器备份。
*   `.rodata` 段：包含只读数据，紧随 `.bss` 之后。
*   `.text` 段：起始于 `0x80000000`。此段包含可执行代码。
    *   `.text.init` 子段：起始于 `0x80000000`，包含引导启动代码。
    *   `.text.ebase` 子段：起始于 `0x80001000` (通过 `. = 0x1000` 偏移)。
    *   `.text.ebase180` 子段：起始于 `0x80001180` (通过 `. = 0x1180` 偏移)。
    *   通用 `.text` 子段：起始于 `0x80002000` (通过 `ALIGN(0x1000)` 偏移)。这包括`utils.S`和`shell.S`中的函数。
    *   `.text.utest` 子段：起始于 `0x80003000` (通过 `ALIGN(0x1000)` 偏移)。这包括`test.S`中的测试函数。

**重要说明：** 提供的反汇编片段中的地址是相对于其段的起始偏移量（例如，`0x2000` 在反汇编中实际对应 `0x80002000`）。

### 3. 全局变量/数据标签的绝对地址

| 标签名称          | 来源文件     | 所属段       | 绝对地址     | 说明                                                         |
| :---------------- | :----------- | :----------- | :----------- | :----------------------------------------------------------- |
| `TCBT`            | `init.S`     | `.bss`       | `0x807F0080` | 线程控制块表，占用8字节。由于`.bss.uregs`先分配，故地址偏移。 |
| `current`         | `init.S`     | `.bss`       | `0x807F0088` | 当前线程TCB地址，占用4字节。                                 |
| `uregs`           | `shell.S`    | `.bss.uregs` | `0x807F0000` | 用户寄存器备份区域，占用32个word（128字节），从`.bss`段起始。 |
| `uregs_sp`        | `kernel.ld`  | `.bss`       | `0x807F0008` | 指向`uregs`数组中存储用户栈指针的偏移地址（`uregs + 2*4`）。 |
| `uregs_fp`        | `kernel.ld`  | `.bss`       | `0x807F0054` | 指向`uregs`数组中存储用户帧指针的偏移地址（`uregs + 21*4`）。 |
| `KERNEL_STACK_INIT` | `kernel.ld`  | -            | `0x80800000` | 内核栈的初始化地址。                                         |
| `USER_STACK_INIT` | `kernel.ld`  | -            | `0x807F0000` | 用户栈的初始化地址（与`uregs`起始地址相同，栈向下增长）。   |
| `SerialData`      | `kernel.ld`  | -            | `0xBFD003F8` | 串口数据寄存器地址。                                         |
| `SerialStat`      | `kernel.ld`  | -            | `0xBFD003FC` | 串口状态寄存器地址。                                         |
| `monitor_version` | `init.S`     | `.text`      | `0x80000004` | 启动信息字符串："MONITOR for Loongarch32 - initialized."     |
| `_sbss`           | `kernel.ld`  | `.text`      | `0x8000002C` | `.bss`段的起始符号地址。                                     |
| `_ebss`           | `kernel.ld`  | `.text`      | `0x80000030` | `.bss`段的结束符号地址。                                     |

### 4. 函数例程的绝对地址

| 函数名称          | 来源文件    | 所属段            | 绝对地址     | 反汇编对应地址 | 说明                                                         |
| :---------------- | :---------- | :---------------- | :----------- | :------------- | :----------------------------------------------------------- |
| `INITLOCATE`      | `evec.S`    | `.text.init`      | `0x80000000` | N/A            | 程序入口点，用于定位`START`函数。                            |
| `START`           | `init.S`    | `.text`           | `0x80000034` | N/A            | 内核初始化程序入口，负责BSS清零和栈初始化。                  |
| `WRITESERIAL`     | `utils.S`   | 通用`.text`       | `0x80002000` | `0x2000`       | 写入一个字节到串口（`a0`低八位）。                         |
| `READSERIAL`      | `utils.S`   | 通用`.text`       | `0x80002028` | `0x2028`       | 从串口读取一个字节并存入`a0`低八位。                       |
| `READSERIALWORD`  | `utils.S`   | 通用`.text`       | `0x80002050` | `0x2050`       | 从串口读取四个字节（一个字）并组合存入`a0`。                 |
| `WELCOME`         | `init.S`    | `.text`           | `0x800000xx` | N/A            | 内核初始化完成后跳转到的欢迎函数（精确地址需完整反汇编）。 |
| `SHELL`           | `shell.S`   | 通用`.text`       | `0x800021e0` | `0x21e0`       | 监控程序的交互主循环。                                       |
| `SHELL.OP_R`      | `shell.S`   | 通用`.text`       | `0x80002214` | `0x2214`       | `SHELL`中处理'R'（打印寄存器）命令的子例程。               |
| `SHELL.OP_D`      | `shell.S`   | 通用`.text`       | `0x80002258` | `0x2258`       | `SHELL`中处理'D'（打印内存）命令的子例程。                 |
| `SHELL.OP_A`      | `shell.S`   | 通用`.text`       | `0x800022b0` | `0x22b0`       | `SHELL`中处理'A'（写入内存）命令的子例程。                 |
| `SHELL.OP_G`      | `shell.S`   | 通用`.text`       | `0x8000230c` | `0x230c`       | `SHELL`中处理'G'（执行用户程序）命令的子例程。             |
| `SHELL.USERRET2`  | `shell.S`   | 通用`.text`       | `0x800023b0` | `0x23b0`       | `SHELL`中用户程序返回后的处理例程。                        |
| `SHELL.DONE`      | `shell.S`   | 通用`.text`       | `0x80002454` | `0x2454`       | `SHELL`中命令处理结束后的跳转目标，通常跳回`SHELL`主循环。 |
| `UTEST_SIMPLE`    | `test.S`    | `.text.utest`     | `0x80003000` | `0x3000`       | 内置的简单测试程序，将`a0`加1。                             |
| `UTEST_STREAM`    | `test.S`    | `.text.utest`     | `0x80003008` | `0x3008`       | 内置的流测试程序，进行连续内存读写。                         |
| `UTEST_MATRIX`    | `test.S`    | `.text.utest`     | `0x80003030` | `0x3030`       | 内置的矩阵乘法测试程序。                                     |
| `UTEST_CRYPTONIGHT` | `test.S`    | `.text.utest`     | `0x800030b4` | `0x30b4`       | 内置的CryptoNight简化版内存密集型循环测试。                |

### 5. 分析方法和限制

本分析通过以下步骤进行：
1.  **理解链接脚本：** 确定各个代码和数据段在最终内存布局中的起始地址。
2.  **关联反汇编与源代码：** 通过识别反汇编中的指令模式和操作数（如对状态/数据寄存器的访问、常量值、分支偏移），将其与源代码中的函数逻辑和全局变量定义进行匹配。
3.  **计算偏移：** 对于在同一代码段内的标签，根据指令长度和对齐要求，从已确定的起始地址计算相对偏移量。

**限制：**
*   **部分反汇编：** 提供的反汇编仅包含了一部分代码，尤其是`0x80000000`到`0x80002000`之间的代码段（`INITLOCATE`, `START`, `WELCOME`等）没有直接的反汇编输出。这些地址是根据链接脚本和代码逻辑推断的。
*   **符号解析：** `la.global`和`la.local`指令在最终机器码中会被转换为`pcaddu12i`和`addi.w`/`ld.w`/`st.w`等指令组合，通过计算其操作数与PC寄存器的相对值来确定目标地址。本分析已根据这些特征进行了推断。

本文档旨在提供一个清晰的映射关系，有助于理解LoongArch32内核的内存布局和代码执行流程。
