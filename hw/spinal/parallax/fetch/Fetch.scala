package parallax.fetch

import spinal.core._
import spinal.lib._
import spinal.lib.pipeline._
import parallax.components.memory._
import parallax.utilities._
import parallax.common._

// Define a service for the split memory bus if it doesn't exist
// This is a placeholder. You'll need a concrete implementation.
trait SplitMemoryService extends Plugin {
  def memBus: SplitGenericMemoryBus // Provided by the memory system plugin
}

case class FetchPipelineSignals(val pipelineConfig: PipelineConfig) extends AreaObject {
  val PC = Stageable(UInt(pipelineConfig.pcWidth)) // pc to fetch
  val FETCHED_PC = Stageable(UInt(pipelineConfig.pcWidth)) // pc that accords with the fetched instruction group
  val REDIRECT_PC = Stageable(UInt(pipelineConfig.pcWidth))
  val REDIRECT_PC_VALID = Stageable(Bool())

  val INSTRUCTION_GROUP = Stageable(Vec(Bits(pipelineConfig.dataWidth), pipelineConfig.fetchWidth))
  val FETCH_FAULT = Stageable(Bool())

  ParallaxLogger.log("FetchPipelineSignals instanciated")
}

class FetchPipeline(val pipelineConfig: PipelineConfig) extends Plugin with LockedImpl {
  lazy val signals = FetchPipelineSignals(pipelineConfig) // Pass pipelineConfig
  ParallaxLogger.log(s"FetchPipeline: signals.PC instance hash: ${System.identityHashCode(signals.PC)}")

  val pipeline = create early new Pipeline {
    val s0_PcGen = newStage().setName("s0_PcGen")
    val s1_Fetch = newStage().setName("s1_Fetch")
    connect(s0_PcGen, s1_Fetch)(Connection.M2S())
  }

  create late new Area {
    lock.await()

    pipeline.build()
    ParallaxLogger.log("FetchPipeline built")
  }

  def entryStage: Stage = pipeline.s0_PcGen
  def exitStage: Stage = pipeline.s1_Fetch
}

// Fetch0Plugin: Generates PC - Largely unchanged, but ensure REDIRECT signals are correctly sourced
class Fetch0Plugin(val pcWidth: BitCount = 32 bits) extends Plugin with LockedImpl {

  val setup = create early new Area {
    val fetchPipeline = getService[FetchPipeline]
    fetchPipeline.retain()
    ParallaxLogger.log(s"Fetch0Plugin: setup")
    // Ensure REDIRECT_PC_VALID and REDIRECT_PC are inserted into s0_PcGen if they
    // are generated by a preceding stage or an external source that targets s0.
    // If they are global/asynchronous, their handling might differ.
    // For now, assuming they are inputs to s0_PcGen.
    fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.REDIRECT_PC_VALID)
    fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.REDIRECT_PC)
    fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.PC)
  }

  val logic = create late new Area {
    val signals = setup.fetchPipeline.signals
    val s0_PcGen = setup.fetchPipeline.pipeline.s0_PcGen
    ParallaxLogger.log(s"Fetch0Plugin: logic")

    val pcReg = Reg(UInt(pcWidth)) init (0)
    val pcPlusIncrement = pcReg + U(setup.fetchPipeline.pipelineConfig.bytesPerInstruction) // Standard increment

    // Access redirect signals from the stage's input view
    val redirectValid = s0_PcGen(signals.REDIRECT_PC_VALID)
    val redirectPc = s0_PcGen(signals.REDIRECT_PC)

    val bootDelay = 2
    val initCounter = Reg(UInt(log2Up(bootDelay + 1) bits)) init (0)
    val booted = Reg(Bool()) init (False)

    when(!booted) {
      initCounter := initCounter + 1
      when(initCounter === bootDelay) {
        booted := True
      }
    }

    val pcLogic = new Area {
      val currentPc = pcReg
      val nextPcCalc = Mux(redirectValid, redirectPc, pcPlusIncrement)

      when(booted) {
        when(s0_PcGen.isFiring || (s0_PcGen.isValid && redirectValid)) {
          pcReg := nextPcCalc
        }
      }

      val isValidToStage = booted
    }

    s0_PcGen.valid := pcLogic.isValidToStage
    s0_PcGen(signals.PC) := pcReg

    // Initialize redirect signals if they are not driven by a previous stage and are meant to be optional inputs
    // This is important if they are not guaranteed to be driven.
    report(
      L"[Fetch0Plugin] s0_PcGen.valid: ${s0_PcGen.valid} booted: ${booted} redirectValid: ${redirectValid} pc: ${pcReg} nextPcCalc: ${pcLogic.nextPcCalc} s0_isFiring: ${s0_PcGen.isFiring}"
    )

    setup.fetchPipeline.release()
  }
}

class Fetch1Plugin(
    val pipelineConfigFromParent: PipelineConfig,
    // This is the GMB config for the I-Bus that IFU will connect to.
    // It should match the iBusGmbConfig of the SimulatedUnifiedBusPlugin (or similar IBusServiceProvider).
    val iBusGmbConfigForIFU: GenericMemoryBusConfig
) extends Plugin
    with LockedImpl {

  // Create the IFUConfig based on PipelineConfig and the specific GMB config for the I-Bus
  val ifuConfig = InstructionFetchUnitConfig(
    useICache = true, // Assuming ICache is used; make this configurable if needed
    enableFlush = false, // Make this configurable if needed
    pcWidth = pipelineConfigFromParent.pcWidth,
    instructionWidth = pipelineConfigFromParent.dataWidth,
    fetchGroupDataWidth = pipelineConfigFromParent.fetchGroupBytes * 8 bits,
    memBusConfig = iBusGmbConfigForIFU // IFU's memory port uses this specific GMB config
  )

  val setup = create early new Area {
    val fetchPipeline = getService[FetchPipeline]
    fetchPipeline.retain()
    ParallaxLogger.log(s"Fetch1Plugin: setup")
    // Get the IBusService
    val iBusProvider = getService[IBusService]
    val s1_Fetch = fetchPipeline.pipeline.s1_Fetch
    val s0_PcGen = fetchPipeline.pipeline.s0_PcGen

    val ifu = new InstructionFetchUnit(ifuConfig)
    ifu.io.memBus <> iBusProvider.iBus.setAsDirectionLess()
  }

  // --- logic Area (largely the same as before) ---
  val logic = create late new Area {
    ParallaxLogger.log(s"Fetch1Plugin: logic")

    val signals = setup.fetchPipeline.signals
    val s1_Fetch = setup.s1_Fetch
    val s0_PcGen = setup.s0_PcGen

    val ifu = setup.ifu // from setup area

    val currentPcForS1 = s1_Fetch(signals.PC)
    val isFetching = Reg(Bool()) init (False)

    val regFetchedPc = Reg(UInt(ifuConfig.pcWidth))
    val regFetchedInstructionGroup = Reg(Vec(Bits(ifuConfig.instructionWidth), pipelineConfigFromParent.fetchWidth))
    val regFetchedFault = Reg(Bool()) init(True)
    val regDataFromIfuIsValid = Reg(Bool()) init (False)

    ifu.io.pcIn.valid := s1_Fetch.isValid && !isFetching && !regDataFromIfuIsValid
    ifu.io.pcIn.payload := currentPcForS1

    // when(s1_Fetch.isFlushed) {
    //   isFetching := False
    //   regDataFromIfuIsValid := False
    // }

    when(ifu.io.pcIn.fire) {
      isFetching := True
      report(L"Fetch1Plugin: fetch started for pc=${ifu.io.pcIn.payload}")
    }

    ifu.io.dataOut.ready := isFetching && !regDataFromIfuIsValid

    when(ifu.io.dataOut.fire) {
      isFetching := False
      regFetchedPc := ifu.io.dataOut.payload.pc
      for (i <- 0 until pipelineConfigFromParent.fetchWidth) {
        regFetchedInstructionGroup(i) := ifu.io.dataOut.payload.instructions(i)
      }
      regFetchedFault := ifu.io.dataOut.payload.fault
      regDataFromIfuIsValid := True
    }

    s1_Fetch(signals.FETCHED_PC) := regFetchedPc
    report(L"Fetch1Plugin: fetched pc=${regFetchedPc}")
    for (i <- 0 until pipelineConfigFromParent.fetchWidth) {
      s1_Fetch(signals.INSTRUCTION_GROUP)(i) := regFetchedInstructionGroup(i)
    }
    s1_Fetch(signals.FETCH_FAULT) := regFetchedFault

    when(s1_Fetch.isFiring && regDataFromIfuIsValid) {
      regDataFromIfuIsValid := False
    }

    // Stall conditions for s1_Fetch:
    // 1. If s1_Fetch has valid input, but it cannot send a new request to IFU because:
    //    a. It's not already fetching (isFetching=False) AND
    //    b. It doesn't have data ready to go (regDataFromIfuIsValid=False) AND
    //    c. IFU is not ready to accept a new PC (ifu.io.pcIn.ready=False).
    val stall_waiting_to_send_to_ifu = s1_Fetch.isValid && !isFetching && !regDataFromIfuIsValid && !ifu.io.pcIn.ready

    // 2. If s1_Fetch is waiting for data from IFU (isFetching=True), but IFU hasn't made it valid yet.
    //    (regDataFromIfuIsValid is implicitly False if isFetching is True, based on state transitions)
    val stall_waiting_for_ifu_data = s1_Fetch.isValid && isFetching && !ifu.io.dataOut.valid

    // 3. (Implicitly Handled by Pipeline) If s1_Fetch has valid data in its registers (regDataFromIfuIsValid=True),
    //    but the downstream stage/bridge is not ready (s1_Fetch.isReady is False), the pipeline automatically stalls s1_Fetch.

    // Halt s1_Fetch if it's supposed to be doing work but cannot make progress.
    // The stage should also effectively stall if it has valid inputs but its output registers are full (regDataFromIfuIsValid = True)
    // and the downstream isn't ready. This is automatically handled by the pipeline if s1_Fetch.isReady (which comes from fetchOutput.ready) is low.
    // The key is that s1_Fetch should only be considered "done" with its current PC and ready to output
    // when regDataFromIfuIsValid is True. If it's True, it will only fire if downstream is ready.
    // If regDataFromIfuIsValid is False, it means s1_Fetch is still working on getting the data.
    s1_Fetch.haltWhen(stall_waiting_to_send_to_ifu || stall_waiting_for_ifu_data)

    // This provides an explicit halt condition if the stage has valid inputs,
    // but hasn't yet latched data from the IFU.
    // This ensures s1_Fetch doesn't fire downstream if regDataFromIfuIsValid is false.
    s1_Fetch.haltWhen(s1_Fetch.isValid && !regDataFromIfuIsValid)

    when(s1_Fetch.isValid && !s1_Fetch.isStuck && !s1_Fetch.isReady && regDataFromIfuIsValid) {
      report(L"Fetch1Plugin: Has valid data in regs, but downstream not ready. PC=${regFetchedPc}")
    }
    when(s1_Fetch.isValid && stall_waiting_to_send_to_ifu) {
      report(L"Fetch1Plugin: Stalling, IFU not ready for new PC. Current S1 PC=${currentPcForS1}")
    }
    when(s1_Fetch.isValid && stall_waiting_for_ifu_data) {
      report(L"Fetch1Plugin: Stalling, waiting for IFU data. Current S1 PC=${currentPcForS1}")
    }
    setup.fetchPipeline.release()
  }
}

// Define the output bundle for the fetch pipeline
case class FetchBridgeOutput(val pipelineConfig: PipelineConfig) extends Bundle {
  val pc = UInt(pipelineConfig.pcWidth)
  // Output a Vec of instructions
  val instructions = Vec(Bits(pipelineConfig.dataWidth), pipelineConfig.fetchWidth)
  val fault = Bool()
}

class FetchOutputBridge(val pipelineConfig: PipelineConfig) extends Plugin with LockedImpl {

  val setup = create early new Area {
    ParallaxLogger.log("[FetchOutputBridge] setup")
    val fetchPipeline = getService[FetchPipeline]
    val s1_Fetch = fetchPipeline.pipeline.s1_Fetch

    // if (s1_Fetch.internals.output.ready == null) {
    //   s1_Fetch.internals.output.ready = Bool()
    // }
    // s1_Fetch.internals.output.ready := fetchOutput.ready
    ParallaxLogger.log("[Bridge] s1_Fetch.internals.output.ready set to fetchOutput.ready")
  }

  // The bridge provides this stream as its output
  val fetchOutput = create early Stream(FetchBridgeOutput(pipelineConfig))

  create late new Area {
    val signals = setup.fetchPipeline.signals
    val s1_Fetch = setup.s1_Fetch

    fetchOutput.valid := s1_Fetch.valid // Bridge output is valid when s1_Fetch output is valid
    fetchOutput.payload.pc := s1_Fetch(signals.FETCHED_PC)
    // Assign the Vec from Stageable to the Bundle's Vec
    for (i <- 0 until pipelineConfig.fetchWidth) {
      fetchOutput.payload.instructions(i) := s1_Fetch(signals.INSTRUCTION_GROUP)(i)
    }
    fetchOutput.payload.fault := s1_Fetch(signals.FETCH_FAULT)
    s1_Fetch.internals.arbitration.propagateReady = true
    s1_Fetch.isReady // 强制实例化 s1_Fetch.internals.output.ready

    when(fetchOutput.fire) { // fire = valid && ready
      report(
        L"[Bridge] Firing output: Valid=${fetchOutput.valid} Ready=${fetchOutput.ready} fetchOutput.payload.pc=${fetchOutput.payload.pc}"
      )
    }
  }
}
