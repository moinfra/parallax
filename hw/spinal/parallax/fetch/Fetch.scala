// package parallax.fetch

// import spinal.core._
// import spinal.lib._
// import spinal.lib.pipeline._
// import parallax.components.memory._
// import parallax.utilities._
// import parallax.common._
// import spinal.core._
// import spinal.lib._
// import parallax.common._
// import parallax.issue.IssuePipeline
// import parallax.utilities.{Plugin, LockedImpl, ParallaxLogger}
// import parallax.components.lsu.SkidBuffer
// import parallax.bpu._

// case class FetchPipelineSignals(val pipelineConfig: PipelineConfig) extends AreaObject {
//   val PC = Stageable(UInt(pipelineConfig.pcWidth)) // pc to fetch
//   val FETCHED_PC = Stageable(UInt(pipelineConfig.pcWidth)) // pc that accords with the fetched instruction group
//   val REDIRECT_PC = Stageable(UInt(pipelineConfig.pcWidth))
//   val REDIRECT_PC_VALID = Stageable(Bool())

//   val INSTRUCTION_GROUP = Stageable(Vec(Bits(pipelineConfig.dataWidth), pipelineConfig.fetchWidth))
//   val FETCH_FAULT = Stageable(Bool())

//   ParallaxLogger.log("FetchPipelineSignals instanciated")
// }

// class FetchPipeline(val pipelineConfig: PipelineConfig) extends Plugin with FetchRedirectService with LockedImpl {
//   lazy val signals = FetchPipelineSignals(pipelineConfig) // Pass pipelineConfig
//   ParallaxLogger.log(s"FetchPipeline: signals.PC instance hash: ${System.identityHashCode(signals.PC)}")

//   val hw = create early new Area {
//     val redirectFlow = Flow(UInt(pipelineConfig.pcWidth))
//   }
//   override def redirectFlow = hw.redirectFlow

//   // S0: PC Generation (s0_PcGen): 生成当前周期的取指PC。
//   // S1: I-Cache/Mem Access & BPU Query (s1_Fetch): 使用S0的PC访问指令存储（ICache/内存），同时将这个PC发送给BPU进行查询。
//   // S2: Prediction & Alignment (s2_Align):
//   //    接收S1取回的指令。
//   //    接收BPU的预测结果（这是对S1发出的查询的响应）。
//   //    执行指令对齐和屏蔽。
//   //    根据预测结果，向S0请求PC重定向。
//   val pipeline = create early new Pipeline {
//     val s0_PcGen = newStage().setName("s0_PcGen")
//     val s1_Fetch = newStage().setName("s1_Fetch")
//     val s2_Align = newStage().setName("s2_Align") // *** 新增阶段 ***

//     connect(s0_PcGen, s1_Fetch)(Connection.M2S())
//     connect(s1_Fetch, s2_Align)(Connection.M2S())
//   }

//   create late new Area {
//     lock.await()

//     pipeline.s0_PcGen(signals.REDIRECT_PC_VALID) := redirectFlow.valid
//     pipeline.s0_PcGen(signals.REDIRECT_PC) := redirectFlow.payload
//     pipeline.build()
//     ParallaxLogger.log("FetchPipeline built")
//   }

//   def entryStage: Stage = pipeline.s0_PcGen
//   def exitStage: Stage = pipeline.s1_Fetch
// }

// // Fetch0Plugin: Generates PC
// class Fetch0Plugin(val pcWidth: BitCount = 32 bits) extends Plugin with LockedImpl {

//   val setup = create early new Area {
//     val fetchPipeline = getService[FetchPipeline]
//     fetchPipeline.retain()
//     ParallaxLogger.log(s"Fetch0Plugin: setup")
//     // Ensure REDIRECT_PC_VALID and REDIRECT_PC are inserted into s0_PcGen if they
//     // are generated by a preceding stage or an external source that targets s0.
//     // If they are global/asynchronous, their handling might differ.
//     // For now, assuming they are inputs to s0_PcGen.
//     fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.REDIRECT_PC_VALID)
//     fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.REDIRECT_PC)
//     fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.PC)
//   }

//   val logic = create late new Area {
//     val signals = setup.fetchPipeline.signals
//     val s0_PcGen = setup.fetchPipeline.pipeline.s0_PcGen
//     ParallaxLogger.log(s"Fetch0Plugin: logic")

//     val pcReg = Reg(UInt(pcWidth)) init (0)
//     val fetchWidth = setup.fetchPipeline.pipelineConfig.fetchWidth
//     val bytesPerGroup = U(setup.fetchPipeline.pipelineConfig.bytesPerInstruction * fetchWidth)
//     val pcPlusIncrement = pcReg + bytesPerGroup
//     // Access redirect signals from the stage's input view
//     val redirectValid = s0_PcGen(signals.REDIRECT_PC_VALID)
//     val redirectPc = s0_PcGen(signals.REDIRECT_PC)

//     val bootDelay = 2
//     val initCounter = Reg(UInt(log2Up(bootDelay + 1) bits)) init (0)
//     val booted = Reg(Bool()) init (False)

//     when(!booted) {
//       initCounter := initCounter + 1
//       when(initCounter === bootDelay) {
//         booted := True
//       }
//     }

//     val pcLogic = new Area {
//       val currentPc = pcReg
//       val nextPcCalc = Mux(redirectValid, redirectPc, pcPlusIncrement)

//       when(booted) {
//         when(s0_PcGen.isFiring || (s0_PcGen.isValid && redirectValid)) {
//           pcReg := nextPcCalc
//           report(L"Fetch0Plugin: pcReg updated to ${pcReg} from ${currentPc}")
//         }
//       }

//       val isValidToStage = booted
//     }

//     s0_PcGen.valid := pcLogic.isValidToStage
//     s0_PcGen(signals.PC) := pcReg
//     report(L"S0_CTRL: s0.isFiring=${s0_PcGen.isFiring} s0.isValid=${s0_PcGen.isValid} s0.isReady=${s0_PcGen.isReady}")
//     report(L"S0_DATA: pcReg=${pcReg} s0_output_PC=${s0_PcGen(signals.PC)}") // s0_output_PC 应该等于 pcReg
//     report(
//       L"S0_FLOW: s0.input.valid=${s0_PcGen.internals.input.valid} s0.input.ready=${s0_PcGen.internals.input.ready}"
//     ) // S0 通常没有input valid/ready

//     // ...
//     // Initialize redirect signals if they are not driven by a previous stage and are meant to be optional inputs
//     // This is important if they are not guaranteed to be driven.
//     report(
//       L"[Fetch0Plugin] s0_PcGen.valid: ${s0_PcGen.valid} booted: ${booted} redirectValid: ${redirectValid} pc: ${pcReg} nextPcCalc: ${pcLogic.nextPcCalc} s0_isFiring: ${s0_PcGen.isFiring}"
//     )

//     setup.fetchPipeline.release()
//   }
// }

// class Fetch1Plugin(
//     val pipelineConfigFromParent: PipelineConfig
//     // 不再需要 iBusGmbConfigForIFU 作为参数
// ) extends Plugin
//     with LockedImpl {

//   // setup 区域会提前执行
//   val setup = create early new Area {
//     val fetchPipeline = getService[FetchPipeline]
//     fetchPipeline.retain()
//     ParallaxLogger.log(s"Fetch1Plugin: setup")

//     // 获取 BPU 服务
//     val bpuService = getService[BpuService]
//     bpuService.retain()
//     val redirectService = getService[FetchRedirectService]

//     // 获取新的 AXI 指令总线服务
//     val iBusProvider = getService[IBusService]

//     // 从服务获取 AXI 配置
//     val ifuConfig = InstructionFetchUnitConfig(
//       useICache = true,
//       enableFlush = false,
//       pcWidth = pipelineConfigFromParent.pcWidth,
//       instructionWidth = pipelineConfigFromParent.dataWidth,
//       fetchGroupDataWidth = pipelineConfigFromParent.fetchGroupBytes * 8 bits,
//       axiConfig = iBusProvider.iBusConfig // **使用服务提供的 AXI 配置**
//     )

//     val s1_Fetch = fetchPipeline.pipeline.s1_Fetch
//     val ifu = new InstructionFetchUnit(ifuConfig)

//     // 直接连接 AXI 总线
//     ifu.io.memBus <> iBusProvider.getIBus()

//     // Example: If flush is enabled and a service exists
//     // if (ifuConfig.enableFlush) {
//     //   val flushService = getServiceOption[SomeCacheFlushService] // Hypothetical
//     //   flushService.foreach(s => ifu.io.flush <> s.createFlushPort())
//     // }

//   }
//   val logic = create late new Area {
//     ParallaxLogger.log(s"Fetch1Plugin: logic LATE area entered")
//     val bpuSignalService = getService[IssueBpuSignalService] // BPU信号服务
//     val bpuSignals = bpuSignalService.getBpuSignals() // 获取BPU信号

//     val signals = setup.fetchPipeline.signals
//     val s1_Fetch = setup.fetchPipeline.pipeline.s1_Fetch
//     val ifu = setup.ifu

//     s1_Fetch(signals.FETCHED_PC)
//     s1_Fetch(signals.INSTRUCTION_GROUP)
//     s1_Fetch(signals.FETCH_FAULT)

//     val waitingIfuRspReg = Reg(Bool()) init (False) // 当成功将指令送入IFU时更新为True，当成功拿到指令后更新为False
//     val rspPcReg = Reg(UInt(pipelineConfigFromParent.pcWidth))
//     val rspInstrGroupReg = Reg(Vec(Bits(pipelineConfigFromParent.dataWidth), pipelineConfigFromParent.fetchWidth))
//     val rspFaultReg = Reg(Bool()) init (True)
//     val rspValidReg = Reg(Bool()) init (False) // 当收到有效指令时更新为 True. 当得到新的PC时更新为 False. 当成功输送下游时更新 False

//     val s1_input_pc = s1_Fetch(signals.PC)
//     ifu.io.pcIn.payload := s1_input_pc
//     ifu.io.pcIn.valid := s1_Fetch.isValid && !waitingIfuRspReg && !rspValidReg

//     val pcInFire = ifu.io.pcIn.fire
//     when(pcInFire) {
//       waitingIfuRspReg := True
//       report(L"Fetch1Plugin: pcInFire, s1_input_pc=$s1_input_pc")
//     }

//     // 如果收到了有效的指令，指令尚未送入IFU，则waitingIfuRspReg依然是False，那么不应该允许输出
//     // s.input.ready := False
//     // s.output.valid := False
//     s1_Fetch.haltIt(
//       !rspValidReg // 如果没有有效影响，则不允许输出
//     )

//     // 当得到流水输入时，禁止输出
//     when(s1_Fetch.isFiring) {
//       rspValidReg := False
//       report(L"Fetch1Plugin: s1_Fetch.isFiring, s1_input_pc=$s1_input_pc")
//     }

//     // 当下游成功消耗
//     when(rspValidReg && s1_Fetch.isForked) {
//       rspValidReg := False
//     }

//     when(ifu.io.dataOut.fire) {
//       waitingIfuRspReg := False
//       rspPcReg := ifu.io.dataOut.payload.pc
//       rspInstrGroupReg := ifu.io.dataOut.payload.instructions
//       rspFaultReg := ifu.io.dataOut.payload.fault
//       rspValidReg := True
//     }

//     s1_Fetch(signals.FETCHED_PC).assignDontCare()
//     s1_Fetch(signals.INSTRUCTION_GROUP).assignDontCare()
//     s1_Fetch(signals.FETCH_FAULT) := True
//     s1_Fetch(bpuSignals.INSTRUCTION_VALID_MASK).clearAll()
//     s1_Fetch(bpuSignals.PREDICTION_INFO).setDefault()

//     val s1IsFiring = s1_Fetch.isFiring

//     ifu.io.dataOut.ready := waitingIfuRspReg

//     // --- 详细报告 ---
//     report(L"S1_IN: s1.isValid=${s1_Fetch.isValid} s1.pcInStage=${s1_input_pc}")
//     report(
//       L"S1_IFU_CMD: pcIn.valid=${ifu.io.pcIn.valid} pcIn.ready=${ifu.io.pcIn.ready} pcIn.payload=${ifu.io.pcIn.payload} pcIn.fire=${pcInFire}"
//     )
//     report(L"S1_STATE: waitingIfuRspReg=${waitingIfuRspReg}")
//     report(
//       L"S1_IFU_RSP: dataOut.valid=${ifu.io.dataOut.valid} dataOut.ready=${ifu.io.dataOut.ready} dataOut.payload.pc=${ifu.io.dataOut.payload.pc} dataOut.fault=${ifu.io.dataOut.payload.fault}"
//     )
//     report(
//       L"S1_FLOW: s1.input.valid=${s1_Fetch.internals.input.valid} s1.input.ready=${s1_Fetch.internals.input.ready}"
//     )
//     report(L"S1_FLOW: s1.isFiring=${s1IsFiring} s1.isStuck=${s1_Fetch.isStuck}")
//     report(L"S1_OUT_STAGEABLES: FETCHED_PC=${s1_Fetch(signals.FETCHED_PC)} FAULT=${s1_Fetch(signals.FETCH_FAULT)}")

//     setup.fetchPipeline.release()
//     ParallaxLogger.log(s"Fetch1Plugin: logic LATE area exited")
//   }
// }

// // Define the output bundle for the fetch pipeline
// case class FetchBridgeOutput(val pipelineConfig: PipelineConfig) extends Bundle {
//   val pc = UInt(pipelineConfig.pcWidth)
//   // Output a Vec of instructions
//   val instructions = Vec(Bits(pipelineConfig.dataWidth), pipelineConfig.fetchWidth)
//   val fault = Bool()
// }

// // Convert fetch output to stream. Used for testing and debugging.
// class FetchOutputBridge(val pipelineConfig: PipelineConfig, val fetchOutput: Stream[FetchBridgeOutput])
//     extends Plugin
//     with LockedImpl {

//   val setup = create early new Area {
//     ParallaxLogger.log("[FetchOutputBridge] setup early")
//     val fetchPipeline = getService[FetchPipeline]
//     fetchPipeline.retain()

//     val s_bridge = fetchPipeline.pipeline.newStage().setName("s_bridge")
//     fetchPipeline.pipeline.connect(fetchPipeline.exitStage, s_bridge)(Connection.DIRECT())

//   }

//   create late new Area {
//     ParallaxLogger.log("[FetchOutputBridge] logic")
//     val signals = setup.fetchPipeline.signals
//     val s_bridge = setup.s_bridge

//     val bridgeStageStream = s_bridge.toStream()
//     bridgeStageStream.ready := fetchOutput.ready

//     fetchOutput.valid := bridgeStageStream.valid

//     fetchOutput.payload.pc := s_bridge(signals.FETCHED_PC)
//     for (i <- 0 until pipelineConfig.fetchWidth) {
//       fetchOutput.payload.instructions(i) := s_bridge(signals.INSTRUCTION_GROUP)(i)
//     }
//     fetchOutput.payload.fault := s_bridge(signals.FETCH_FAULT)

//     // Reports
//     when(fetchOutput.fire) {
//       report(
//         L"[BridgeFiringOutput] PC=${fetchOutput.payload.pc} Valid=${fetchOutput.valid} Ready=${fetchOutput.ready}"
//       )
//     }
//     when(s_bridge.isFiring) { // isFiring = s_bridge.isValid (input) && s_bridge.isReady (input)
//       // s_bridge.isReady (input) is affected by haltIt(!fetchOutput.ready)
//       report(L"[BridgeStageFiring] InputData(FETCHED_PC)=${s_bridge(signals.FETCHED_PC)}")
//     }
//     report(
//       L"[BridgeStage] isFiring=${s_bridge.isFiring} isValid=${s_bridge.isValid} isReady=${s_bridge.isReady} isStuck=${s_bridge.isStuck}"
//     )
//     setup.fetchPipeline.release()
//   }
// }
