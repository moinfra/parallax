package parallax.fetch

import spinal.core._
import spinal.lib._
import spinal.lib.pipeline._
import parallax.components.memory._
import parallax.utilities._
import parallax.common._

// Define a service for the split memory bus if it doesn't exist
// This is a placeholder. You'll need a concrete implementation.
trait SplitMemoryService extends Plugin {
  def memBus: SplitGenericMemoryBus // Provided by the memory system plugin
}

case class FetchPipelineSignals(val pipelineConfig: PipelineConfig) extends AreaObject {
  val PC = Stageable(UInt(pipelineConfig.pcWidth)) // pc to fetch
  val FETCHED_PC = Stageable(UInt(pipelineConfig.pcWidth)) // pc that accords with the fetched instruction group
  val REDIRECT_PC = Stageable(UInt(pipelineConfig.pcWidth))
  val REDIRECT_PC_VALID = Stageable(Bool())

  val INSTRUCTION_GROUP = Stageable(Vec(Bits(pipelineConfig.dataWidth), pipelineConfig.fetchWidth))
  val FETCH_FAULT = Stageable(Bool())

  ParallaxLogger.log("FetchPipelineSignals instanciated")
}

class FetchPipeline(val pipelineConfig: PipelineConfig) extends Plugin with LockedImpl {
  lazy val signals = FetchPipelineSignals(pipelineConfig) // Pass pipelineConfig
  ParallaxLogger.log(s"FetchPipeline: signals.PC instance hash: ${System.identityHashCode(signals.PC)}")

  val pipeline = create early new Pipeline {
    val s0_PcGen = newStage().setName("s0_PcGen")
    val s1_Fetch = newStage().setName("s1_Fetch")
    connect(s0_PcGen, s1_Fetch)(Connection.M2S())
  }

  create late new Area {
    lock.await()

    pipeline.build()
    ParallaxLogger.log("FetchPipeline built")
  }

  def entryStage: Stage = pipeline.s0_PcGen
  def exitStage: Stage = pipeline.s1_Fetch
}

// Fetch0Plugin: Generates PC - Largely unchanged, but ensure REDIRECT signals are correctly sourced
class Fetch0Plugin(val pcWidth: BitCount = 32 bits) extends Plugin with LockedImpl {

  val setup = create early new Area {
    val fetchPipeline = getService[FetchPipeline]
    fetchPipeline.retain()
    ParallaxLogger.log(s"Fetch0Plugin: setup")
    // Ensure REDIRECT_PC_VALID and REDIRECT_PC are inserted into s0_PcGen if they
    // are generated by a preceding stage or an external source that targets s0.
    // If they are global/asynchronous, their handling might differ.
    // For now, assuming they are inputs to s0_PcGen.
    fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.REDIRECT_PC_VALID)
    fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.REDIRECT_PC)
    fetchPipeline.pipeline.s0_PcGen(fetchPipeline.signals.PC)
  }

  val logic = create late new Area {
    val signals = setup.fetchPipeline.signals
    val s0_PcGen = setup.fetchPipeline.pipeline.s0_PcGen
    ParallaxLogger.log(s"Fetch0Plugin: logic")

    val pcReg = Reg(UInt(pcWidth)) init (0)
    val fetchWidth = setup.fetchPipeline.pipelineConfig.fetchWidth
    val bytesPerGroup = U(setup.fetchPipeline.pipelineConfig.bytesPerInstruction * fetchWidth)
    val pcPlusIncrement = pcReg + bytesPerGroup
    // Access redirect signals from the stage's input view
    val redirectValid = s0_PcGen(signals.REDIRECT_PC_VALID)
    val redirectPc = s0_PcGen(signals.REDIRECT_PC)

    val bootDelay = 2
    val initCounter = Reg(UInt(log2Up(bootDelay + 1) bits)) init (0)
    val booted = Reg(Bool()) init (False)

    when(!booted) {
      initCounter := initCounter + 1
      when(initCounter === bootDelay) {
        booted := True
      }
    }

    val pcLogic = new Area {
      val currentPc = pcReg
      val nextPcCalc = Mux(redirectValid, redirectPc, pcPlusIncrement)

      when(booted) {
        when(s0_PcGen.isFiring || (s0_PcGen.isValid && redirectValid)) {
          pcReg := nextPcCalc
          report(L"Fetch0Plugin: pcReg updated to ${pcReg} from ${currentPc}")
        }
      }

      val isValidToStage = booted
    }

    s0_PcGen.valid := pcLogic.isValidToStage
    s0_PcGen(signals.PC) := pcReg
    report(L"S0_CTRL: s0.isFiring=${s0_PcGen.isFiring} s0.isValid=${s0_PcGen.isValid} s0.isReady=${s0_PcGen.isReady}")
    report(L"S0_DATA: pcReg=${pcReg} s0_output_PC=${s0_PcGen(signals.PC)}") // s0_output_PC 应该等于 pcReg
    report(
      L"S0_FLOW: s0.input.valid=${s0_PcGen.internals.input.valid} s0.input.ready=${s0_PcGen.internals.input.ready}"
    ) // S0 通常没有input valid/ready

    // ...
    // Initialize redirect signals if they are not driven by a previous stage and are meant to be optional inputs
    // This is important if they are not guaranteed to be driven.
    report(
      L"[Fetch0Plugin] s0_PcGen.valid: ${s0_PcGen.valid} booted: ${booted} redirectValid: ${redirectValid} pc: ${pcReg} nextPcCalc: ${pcLogic.nextPcCalc} s0_isFiring: ${s0_PcGen.isFiring}"
    )

    setup.fetchPipeline.release()
  }
}

class Fetch1Plugin(
    val pipelineConfigFromParent: PipelineConfig,
    // This is the GMB config for the I-Bus that IFU will connect to.
    // It should match the iBusGmbConfig of the SimulatedUnifiedBusPlugin (or similar IBusServiceProvider).
    val iBusGmbConfigForIFU: GenericMemoryBusConfig
) extends Plugin
    with LockedImpl {

  // Create the IFUConfig based on PipelineConfig and the specific GMB config for the I-Bus
  val ifuConfig = InstructionFetchUnitConfig(
    useICache = true, // Assuming ICache is used; make this configurable if needed
    enableFlush = false, // Make this configurable if needed
    pcWidth = pipelineConfigFromParent.pcWidth,
    instructionWidth = pipelineConfigFromParent.dataWidth, // Width of a single instruction
    fetchGroupDataWidth = pipelineConfigFromParent.fetchGroupBytes * 8 bits, // Total width for the group
    memBusConfig = iBusGmbConfigForIFU // IFU's memory port uses this specific GMB config
  )

  val setup = create early new Area {
    val fetchPipeline = getService[FetchPipeline]
    fetchPipeline.retain()
    ParallaxLogger.log(s"Fetch1Plugin: setup")

    val iBusProvider = getService[IBusService]
    val s1_Fetch = fetchPipeline.pipeline.s1_Fetch

    val ifu = new InstructionFetchUnit(ifuConfig)
    ifu.io.memBus <> iBusProvider.iBus.setAsDirectionLess()

    // Example: If flush is enabled and a service exists
    // if (ifuConfig.enableFlush) {
    //   val flushService = getServiceOption[SomeCacheFlushService] // Hypothetical
    //   flushService.foreach(s => ifu.io.flush <> s.createFlushPort())
    // }
  }
  val logic = create late new Area {
    ParallaxLogger.log(s"Fetch1Plugin: logic LATE area entered")

    val signals = setup.fetchPipeline.signals
    val s1_Fetch = setup.fetchPipeline.pipeline.s1_Fetch
    val ifu = setup.ifu

    s1_Fetch(signals.FETCHED_PC)
    s1_Fetch(signals.INSTRUCTION_GROUP)
    s1_Fetch(signals.FETCH_FAULT)

    val waitingIfuRspReg = Reg(Bool()) init (False) // 当成功将指令送入IFU时更新为True，当成功拿到指令后更新为False
    val rspPcReg = Reg(UInt(pipelineConfigFromParent.pcWidth))
    val rspInstrGroupReg = Reg(Vec(Bits(pipelineConfigFromParent.dataWidth), pipelineConfigFromParent.fetchWidth))
    val rspFaultReg = Reg(Bool()) init (True)
    val rspValidReg = Reg(Bool()) init (False) // 当收到有效指令时更新为 True. 当得到新的PC时更新为 False. 当成功输送下游时更新 False

    val s1_input_pc = s1_Fetch(signals.PC)
    ifu.io.pcIn.payload := s1_input_pc
    ifu.io.pcIn.valid := s1_Fetch.isValid && !waitingIfuRspReg && !rspValidReg

    val pcInFire = ifu.io.pcIn.fire
    when(pcInFire) {
      waitingIfuRspReg := True
      report(L"Fetch1Plugin: pcInFire, s1_input_pc=$s1_input_pc")
    }

    // 如果收到了有效的指令，指令尚未送入IFU，则waitingIfuRspReg依然是False，那么不应该允许输出
    s1_Fetch.haltIt(
      !rspValidReg // 如果没有有效影响，则不允许输出
    )

    // 当得到流水输入时，禁止输出
    when(s1_Fetch.isFiring) {
      rspValidReg := False
      report(L"Fetch1Plugin: s1_Fetch.isFiring, s1_input_pc=$s1_input_pc")
    }

    // 当下游成功消耗
    when(rspValidReg && s1_Fetch.isForked) {
      rspValidReg:= False
    }

    when(ifu.io.dataOut.fire) {
      waitingIfuRspReg := False
      rspPcReg := ifu.io.dataOut.payload.pc
      rspInstrGroupReg := ifu.io.dataOut.payload.instructions
      rspFaultReg := ifu.io.dataOut.payload.fault
      rspValidReg := True
    }
    s1_Fetch(signals.FETCHED_PC) := rspPcReg
    s1_Fetch(signals.INSTRUCTION_GROUP) := rspInstrGroupReg
    s1_Fetch(signals.FETCH_FAULT) := rspFaultReg

    val s1IsFiring = s1_Fetch.isFiring

    ifu.io.dataOut.ready := waitingIfuRspReg

    // --- 详细报告 ---
    report(L"S1_IN: s1.isValid=${s1_Fetch.isValid} s1.pcInStage=${s1_input_pc}")
    report(
      L"S1_IFU_CMD: pcIn.valid=${ifu.io.pcIn.valid} pcIn.ready=${ifu.io.pcIn.ready} pcIn.payload=${ifu.io.pcIn.payload} pcIn.fire=${pcInFire}"
    )
    report(L"S1_STATE: waitingIfuRspReg=${waitingIfuRspReg}")
    report(
      L"S1_IFU_RSP: dataOut.valid=${ifu.io.dataOut.valid} dataOut.ready=${ifu.io.dataOut.ready} dataOut.payload.pc=${ifu.io.dataOut.payload.pc} dataOut.fault=${ifu.io.dataOut.payload.fault}"
    )
    report(
      L"S1_FLOW: s1.input.valid=${s1_Fetch.internals.input.valid} s1.input.ready=${s1_Fetch.internals.input.ready}"
    )
    report(L"S1_FLOW: s1.isFiring=${s1IsFiring} s1.isStuck=${s1_Fetch.isStuck}")
    report(L"S1_OUT_STAGEABLES: FETCHED_PC=${s1_Fetch(signals.FETCHED_PC)} FAULT=${s1_Fetch(signals.FETCH_FAULT)}")

    setup.fetchPipeline.release()
    ParallaxLogger.log(s"Fetch1Plugin: logic LATE area exited")
  }
}

// Define the output bundle for the fetch pipeline
case class FetchBridgeOutput(val pipelineConfig: PipelineConfig) extends Bundle {
  val pc = UInt(pipelineConfig.pcWidth)
  // Output a Vec of instructions
  val instructions = Vec(Bits(pipelineConfig.dataWidth), pipelineConfig.fetchWidth)
  val fault = Bool()
}

// -- MODIFICATION START (FetchOutputBridge using inserted stage and toStream) --
class FetchOutputBridge(val pipelineConfig: PipelineConfig, val fetchOutput: Stream[FetchBridgeOutput])
    extends Plugin
    with LockedImpl {

  val setup = create early new Area {
    ParallaxLogger.log("[FetchOutputBridge] setup early")
    val fetchPipeline = getService[FetchPipeline]
    fetchPipeline.retain()

    val s_bridge = fetchPipeline.pipeline.newStage().setName("s_bridge")
    fetchPipeline.pipeline.connect(fetchPipeline.exitStage, s_bridge)(Connection.DIRECT())

  }

  create late new Area {
    ParallaxLogger.log("[FetchOutputBridge] logic")
    val signals = setup.fetchPipeline.signals
    val s_bridge = setup.s_bridge

    val bridgeStageStream = s_bridge.toStream()
    bridgeStageStream.ready := fetchOutput.ready

    // Drive the payload and the final valid signal of the fetchOutput Stream
    // The valid from toStream() is s_bridge.isValid (input valid) AND !s_bridge.isRemoved.
    // We need fetchOutput.valid to be true only when s_bridge *actually fires* data
    // or more precisely, when s_bridge's output would be valid based on its internal logic.
    //
    // `s_bridge.isFiring` is `s_bridge.internals.output.valid && s_bridge.internals.output.ready`
    // `s_bridge.internals.output.valid` is `s_bridge.internals.input.valid` (from previous stage) unless halted/spawned.
    // `s_bridge.internals.output.ready` is driven by `fetchOutput.ready` via the `haltIt(!fetchOutput.ready)` in `toStream()` effect on `s_bridge.internals.input.ready`.

    // Let's use s_bridge.isFiring to drive the actual output stream's valid.
    // This ensures data is only considered valid on the output stream when the stage is truly processing and ready to send.
    // However, s_bridge.isFiring might be too restrictive if s_bridge.internals.output.valid itself is what we want.

    // The `toStream()` method's `ret.valid` is `s_bridge.isValid && !s_bridge.isRemoved`.
    // This `ret.valid` is the valid signal from s_bridge *before* considering s_bridge.isReady (downstream).
    fetchOutput.valid := bridgeStageStream.valid
    // This means fetchOutput.valid is high if s_bridge has valid input (from s1_fetch) and is not removed.
    // The flow control (s_bridge being halted if fetchOutput.ready is low) is handled by toStream's haltIt.

    fetchOutput.payload.pc := s_bridge(signals.FETCHED_PC)
    for (i <- 0 until pipelineConfig.fetchWidth) {
      fetchOutput.payload.instructions(i) := s_bridge(signals.INSTRUCTION_GROUP)(i)
    }
    fetchOutput.payload.fault := s_bridge(signals.FETCH_FAULT)

    // Reports
    when(fetchOutput.fire) {
      report(
        L"[BridgeFiringOutput] PC=${fetchOutput.payload.pc} Valid=${fetchOutput.valid} Ready=${fetchOutput.ready}"
      )
    }
    when(s_bridge.isFiring) { // isFiring = s_bridge.isValid (input) && s_bridge.isReady (input)
      // s_bridge.isReady (input) is affected by haltIt(!fetchOutput.ready)
      report(L"[BridgeStageFiring] InputData(FETCHED_PC)=${s_bridge(signals.FETCHED_PC)}")
    }
    report(
      L"[BridgeStage] isFiring=${s_bridge.isFiring} isValid=${s_bridge.isValid} isReady=${s_bridge.isReady} isStuck=${s_bridge.isStuck}"
    )
    setup.fetchPipeline.release()
  }
}
// -- MODIFICATION END --
